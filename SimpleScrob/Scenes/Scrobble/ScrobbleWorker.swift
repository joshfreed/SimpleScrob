//
//  ScrobbleWorker.swift
//  SimpleScrob
//
//  Created by Josh Freed on 9/30/17.
//  Copyright (c) 2017 Josh Freed. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

class ScrobbleWorker {
    let api: LastFMAPI
    let database: Database
    let session: Session
    let songScanner: SongScanner
    
    var currentUser: User? {
        return session.currentUser
    }
    
    var isLoggedIn: Bool {
        return session.currentUser != nil
    }
    
    init(
        api: LastFMAPI,
        database: Database,
        session: Session,
        songScanner: SongScanner
    ) {
        self.api = api
        self.database = database
        self.session = session
        self.songScanner = songScanner
    }

    func signOut() {
        session.end()
    }
    
    func searchForNewSongsToScrobble(completion: @escaping ([PlayedSong]) -> ()) {
        DispatchQueue.global(qos: .background).async {
            let playedSongs: [PlayedSong] = self.songScanner.searchForNewScrobbles()

            print("Found \(playedSongs.count) played songs")
            
            // Remove any that are already in the database
//            let filteredSongs = playedSongs.filter({ self.database.findById($0.id) != nil })
            
//            print("Found \(filteredSongs.count) songs to insert")
            
            self.database.insert(playedSongs: playedSongs) {
                self.database.findUnscrobbledSongs { playedSongs in
                    DispatchQueue.main.async {
                        completion(playedSongs)
                    }
                }
            }
        }
    }

    func submit(songs: [PlayedSong], completion: @escaping (Error?) -> ()) {
        // Guard: must be logged in
        // Guard: must be connected to the network

        submitBatch(start: 0, songs: songs, completion: completion)        
    }
    
    func submitBatch(start: Int, songs: [PlayedSong], completion: @escaping (Error?) -> ()) {
        guard songs.count > 0 else {
            return completion(nil)
        }
        guard start < songs.count else {
            return completion(nil)
        }
        
        let end = min(start + 50, songs.count)
        var batch = Array(songs[start..<end])
        
        guard batch.count > 0 else {
            return completion(nil)
        }
        
        api.scrobble(songs: batch) { result in
            // Error codes 11, 16 mean we need to try again. Halt the batch submission and print a message "Temporarily unavailable, try again."
            // Error code 9 means bad session, need to re-auth. Halt the batch and print ""
            // All other error code mean the request was malformed in some way and should not be retried
            // All of the above should halt the batch and inform the interactor to present an error.
            // However, any songs that WERE scrobbled should be remembered - updated in the database; NOT scrobbled again
            
            switch result {
            case .success:
                for i in 0..<batch.count {
                    batch[i].scrobbled()
                }
                self.database.save(playedSongs: batch) {}
                self.submitBatch(start: end, songs: songs, completion: completion)
            case .failure(let error):
                for i in 0..<batch.count {
                    batch[i].failedToScrobble(error: error)                    
                }
                self.database.save(playedSongs: batch) {}
                completion(error)
            }
        }
    }
}
