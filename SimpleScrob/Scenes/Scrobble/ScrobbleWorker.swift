//
//  ScrobbleWorker.swift
//  SimpleScrob
//
//  Created by Josh Freed on 9/30/17.
//  Copyright (c) 2017 Josh Freed. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

class ScrobbleWorker {
    let api: LastFMAPI
    let database: Database
    let session: Session
    let songScanner: SongScanner
    let batchUpdater: BatchSongUpdater
    
    var currentUser: User? {
        return session.currentUser
    }
    
    var isLoggedIn: Bool {
        return session.currentUser != nil
    }
    
    init(
        api: LastFMAPI,
        database: Database,
        session: Session,
        songScanner: SongScanner,
        batchUpdater: BatchSongUpdater
    ) {
        self.api = api
        self.database = database
        self.session = session
        self.songScanner = songScanner
        self.batchUpdater = batchUpdater
    }

    func signOut() {
        session.end()
    }
    
    func searchForNewSongsToScrobble(completion: @escaping ([PlayedSong]) -> ()) {
        DispatchQueue.global(qos: .background).async {
            let playedSongs: [PlayedSong] = self.songScanner.searchForNewScrobbles()

            print("Found \(playedSongs.count) played songs")
            
            self.database.insert(playedSongs: playedSongs) {
                self.database.findUnscrobbledSongs { playedSongs in
                    DispatchQueue.main.async {
                        completion(playedSongs)
                    }
                }
            }
        }
    }

    func submit(songs: [PlayedSong], completion: @escaping (Error?) -> ()) {
        guard session.isLoggedIn else {
            batchUpdater.markNotScrobbled(songs: songs, with: .notSignedIn)
            return completion(LastFM.ErrorType.notSignedIn)
        }
        // todo : must be connected to the network

        submitBatch(start: 0, songs: songs, completion: completion)        
    }
    
    func submitBatch(start: Int, songs: [PlayedSong], completion: @escaping (Error?) -> ()) {
        guard songs.count > 0 else {
            return completion(nil)
        }
        guard start < songs.count else {
            return completion(nil)
        }
        
        let end = min(start + 50, songs.count)
        let batch = Array(songs[start..<end])
        
        guard batch.count > 0 else {
            return completion(nil)
        }
        
        api.scrobble(songs: batch) { result in
            // Error codes 11, 16 mean we need to try again. Halt the batch submission and print a message "Temporarily unavailable, try again."
            // Error code 9 means bad session, need to re-auth. Halt the batch and print ""
            // All other error code mean the request was malformed in some way and should not be retried
            // All of the above should halt the batch and inform the interactor to present an error.
            // However, any songs that WERE scrobbled should be remembered - updated in the database; NOT scrobbled again
            
            switch result {
            case .success:
                self.batchUpdater.markScrobbled(songs: batch)
                self.submitBatch(start: end, songs: songs, completion: completion)
            case .failure(let error):
                self.batchUpdater.markFailed(songs: batch, with: error)
                completion(error)
            }
        }
    }
}

class BatchSongUpdater {
    let database: Database
    
    init(database: Database) {
        self.database = database
    }
    
    func markScrobbled(songs: [PlayedSong]) {
        var _songs = songs
        for i in 0..<_songs.count {
            _songs[i].scrobbled()
        }
        database.save(playedSongs: _songs) {}
    }
    
    func markFailed(songs: [PlayedSong], with error: LastFM.ErrorType) {
        var _songs = songs
        for i in 0..<_songs.count {
            _songs[i].failedToScrobble(error: error)
        }
        database.save(playedSongs: _songs) {}
    }
    
    func markNotScrobbled(songs: [PlayedSong], with error: LastFM.ErrorType) {
        var _songs = songs
        for i in 0..<_songs.count {
            _songs[i].notScrobbled(reason: error)
        }
        database.save(playedSongs: _songs) {}
    }
}
