//
//  ScrobbleWorker.swift
//  SimpleScrob
//
//  Created by Josh Freed on 9/30/17.
//  Copyright (c) 2017 Josh Freed. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import JFLib
import CocoaLumberjack

class ScrobbleWorker {
    let database: Database
    let songScanner: SongScanner    
    let scrobbleService: ScrobbleService
    let connectivity: Connectivity
    
    var currentUserName: String? {
        return scrobbleService.currentUserName
    }
    
    var isLoggedIn: Bool {
        return scrobbleService.isLoggedIn
    }
    
    init(
        database: Database,
        songScanner: SongScanner,        
        scrobbleService: ScrobbleService,
        connectivity: Connectivity
    ) {
        self.database = database
        self.songScanner = songScanner        
        self.scrobbleService = scrobbleService
        self.connectivity = connectivity
    }

    func signOut() {
        scrobbleService.signOut()
    }
    
    func initializeMusicLibrary() {
        songScanner.initializeSongDatabase()
    }
    
    func searchForNewSongsToScrobble(completion: @escaping ([PlayedSong]) -> ()) {
        DispatchQueue.global(qos: .background).async {
            self.songScanner.searchForNewScrobbles() { playedSongs in
                self.database.insert(playedSongs: playedSongs) {
                    self.database.findUnscrobbledSongs { playedSongs in
                        DispatchQueue.main.async {
                            DDLogDebug("Found \(playedSongs.count) unscrobbled songs")
                            completion(playedSongs)
                        }
                    }
                }
            }
        }
    }

    func submit(songs: [PlayedSong], completion: @escaping (Error?) -> ()) {
        delay(seconds: 0.5) {
            guard self.connectivity.isConnectedToInternet else {
                let updatedSongs = self.markNotScrobbled(songs: songs, with: ScrobbleError.notConnected.description)
                self.database.save(playedSongs: updatedSongs, completion: {})
                completion(ScrobbleError.notConnected)
                return
            }
            
            self.scrobbleService.scrobble(songs: songs) { updatedSongs, error in
                self.database.save(playedSongs: updatedSongs, completion: {})
                completion(error)
            }
        }
    }
    
    func markNotScrobbled(songs: [PlayedSong], with reason: String) -> [PlayedSong] {
        var _songs = songs
        for i in 0..<_songs.count {
            _songs[i].notScrobbled(reason: reason)
        }
        return _songs
    }
}

enum ScrobbleError: Error, CustomStringConvertible {
    case notConnected
    
    var description: String {
        switch self {
        case .notConnected: return "Not connected to the Internet"
        }
    }
}
