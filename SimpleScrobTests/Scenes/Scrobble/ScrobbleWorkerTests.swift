//
//  ScrobbleWorkerTests.swift
//  SimpleScrob
//
//  Created by Josh Freed on 10/5/17.
//  Copyright (c) 2017 Josh Freed. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

@testable import SimpleScrob
import XCTest
import Nimble

class ScrobbleWorkerTests: XCTestCase {
    // MARK: Subject under test

    var sut: ScrobbleWorker!
    let api = MockLastFMApi()
    let database = MockDatabase()
    let session = MockSession()

    // MARK: Test lifecycle

    override func setUp() {
        super.setUp()
        continueAfterFailure = false
        setupScrobbleWorker()
    }

    override func tearDown() {
        super.tearDown()
    }

    // MARK: Test setup

    func setupScrobbleWorker() {
        sut = ScrobbleWorker(
            api: api,
            database: database,
            session: session
        )
    }

    // MARK: Test doubles

    // MARK: Tests

    func testSubmitLessThan50Songs() {
        // Given
        let songs = [
            Song(id: 1, artist: "Beardfish", track: "Sunrise", lastPlayedDate: nil, playCount: 1),
            Song(id: 2, artist: "Beardfish", track: "Afternoon Conversation", lastPlayedDate: nil, playCount: 1)
        ]
        let response = LastFM.ScrobbleResponse(accepted: [], ignored: [])
        api.scrobbleResults.append(.success(response))
        var completionCalled = false
        var completionError: Error?
        let completionExpectation = expectation(description: "Submission completes")

        // When
        sut.submit(songs: songs) { error in
            completionCalled = true
            completionError = error
            completionExpectation.fulfill()
        }

        // Then
        wait(for: [completionExpectation], timeout: 3)
        expect(self.api.scrobbleCallCount).to(equal(1))
        expect(self.api.scrobbleSongs[0]).to(equal(songs))
        expect(completionCalled).to(beTrue())
        expect(completionError).to(beNil())
    }
    
    func testSubmitMoreThan50Songs() {
        // Given
        let batch1 = makeSongs(count: 50)
        let batch2 = makeSongs(count: 50)
        let batch3 = makeSongs(count: 26)
        var allSongs: [Song] = []
        allSongs.append(contentsOf: batch1)
        allSongs.append(contentsOf: batch2)
        allSongs.append(contentsOf: batch3)
        api.scrobbleResults.append(.success(LastFM.ScrobbleResponse(accepted: [], ignored: [])))
        api.scrobbleResults.append(.success(LastFM.ScrobbleResponse(accepted: [], ignored: [])))
        api.scrobbleResults.append(.success(LastFM.ScrobbleResponse(accepted: [], ignored: [])))
        var completionCalled = false
        var completionError: Error?
        let completionExpectation = expectation(description: "Submission completes")
        
        // When
        sut.submit(songs: allSongs) { error in
            completionCalled = true
            completionError = error
            completionExpectation.fulfill()
        }
        
        // Then
        wait(for: [completionExpectation], timeout: 3)
        expect(self.api.scrobbleCallCount).to(equal(3))
        expect(self.api.scrobbleSongs[0]).to(equal(batch1))
        expect(self.api.scrobbleSongs[1]).to(equal(batch2))
        expect(self.api.scrobbleSongs[2]).to(equal(batch3))
        expect(completionCalled).to(beTrue())
        expect(completionError).to(beNil())
        expect(self.database.saveCallCount).to(equal(3))
        expect(self.database.savedSongs[0]).to(equal(batch1))
        expect(self.database.savedSongs[1]).to(equal(batch2))
        expect(self.database.savedSongs[2]).to(equal(batch3))
    }
    
    func testSubmitHadErrors() {
        let batch1 = makeSongs(count: 50)
        let batch2 = makeSongs(count: 50)
        let batch3 = makeSongs(count: 26)
        var allSongs: [Song] = []
        allSongs.append(contentsOf: batch1)
        allSongs.append(contentsOf: batch2)
        allSongs.append(contentsOf: batch3)
        api.scrobbleResults.append(.success(LastFM.ScrobbleResponse(accepted: [], ignored: [])))
        api.scrobbleResults.append(.failure(.error(code: 11, message: "Whatever")))
        api.scrobbleResults.append(.success(LastFM.ScrobbleResponse(accepted: [], ignored: [])))
        var completionCalled = false
        var completionError: Error?
        let completionExpectation = expectation(description: "Submission completes")
        
        // When
        sut.submit(songs: allSongs) { error in
            completionCalled = true
            completionError = error
            completionExpectation.fulfill()
        }
        
        // Then
        wait(for: [completionExpectation], timeout: 3)
        expect(completionCalled).to(beTrue())
        expect(completionError).to(matchError(LastFM.ErrorType.error(code: 11, message: "Whatever")))
        expect(self.api.scrobbleCallCount).to(equal(2))
        expect(self.database.saveCallCount).to(equal(1))
    }
    
    // MARK: Helper Funcs
    
    private var _songId: SongID = 1
    func makeSongs(count: Int) -> [Song] {
        var songs: [Song] = []
        for _ in 0..<count {
            songs.append(Song(id: _songId, artist: "Artist\(_songId)", track: "Track\(_songId)", lastPlayedDate: nil, playCount: 1))
            _songId += 1
        }
        return songs
    }
}
